name: Deploy to Dev

# 워크플로우 트리거 설정
on:
  # 수동으로 워크플로우를 트리거할 수 있습니다.
  workflow_dispatch:
  # 특정 브랜치에 푸시할 때 워크플로우를 트리거합니다.
  push:
    branches:
      - feature/backcicd
  # 특정 브랜치에 대한 PR이 닫힐 때 워크플로우를 트리거합니다.
  pull_request:
    branches:
      - feature/backcicd
    types:
      - closed

jobs:
  deploy:
    # 워크플로우가 실행될 환경을 설정합니다. 여기서는 최신 Ubuntu를 사용합니다.
    runs-on: ubuntu-latest

    steps:
      # 리포지토리의 코드를 체크아웃합니다.
      - name: Checkout
        uses: actions/checkout@v3

      # JDK 17을 설정합니다.
      - name: Set up JDK 17
        uses: actions/setup-java@v2
        with:
          java-version: '17'
          distribution: 'adopt'

      # gradlew 파일에 실행 권한을 부여합니다.
      - name: Grant execute permission for gradlew
        run: chmod +x ./gradlew

      # 유닛 테스트를 실행합니다.
      - name: Run unit tests
        run: ./gradlew clean test

      # Spring Boot 애플리케이션의 JAR 파일을 빌드합니다.
      - name: Build Jar
        run: ./gradlew bootJar

      # JAR 파일이 올바르게 생성되었는지 확인합니다.
      - name: Verify Jar File
        run: test -f build/libs/itsmine-0.0.1-SNAPSHOT.jar && echo "JAR file exists" || echo "JAR file does not exist"

      # Docker 이미지를 빌드합니다.
      - name: Build Docker image
        run: docker build -t itsmine .

      # Amazon ECR에 로그인합니다.
      - name: Log in to Amazon ECR
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          # AWS CLI를 사용하여 ECR에 로그인합니다.
          aws ecr get-login-password --region ${{ secrets.AWS_REGION }} | docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com

      # Docker 이미지에 태그를 지정합니다.
      - name: Tag Docker image
        id: tag_image
        run: |
          # 현재 시간을 타임스탬프로 저장합니다.
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          # 이미지 태그를 커밋 SHA와 타임스탬프를 조합하여 생성합니다.
          IMAGE_TAG=${{ github.sha }}-$TIMESTAMP
          docker tag itsmine:latest ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/itsmine-repository:$IMAGE_TAG
          echo "::set-output name=IMAGE_TAG::$IMAGE_TAG"

      # Docker 이미지를 Amazon ECR에 푸시합니다.
      - name: Push Docker image to ECR
        run: docker push ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/itsmine-repository:${{ steps.tag_image.outputs.IMAGE_TAG }}

      # Amazon EC2 인스턴스에 SSH로 접속하여 Docker 컨테이너를 배포합니다.
      - name: SSH into EC2 and deploy Docker container
        uses: appleboy/ssh-action@v0.1.6
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ec2-user
          key: ${{ secrets.SSH_KEY }}
          port: 22
          script_stop: true
          script: |
            # ECR에 로그인합니다.
            aws ecr get-login-password --region ${{ secrets.AWS_REGION }} | docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com
            # ECR에서 Docker 이미지를 풀합니다.
            docker pull ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/itsmine-repository:${{ steps.tag_image.outputs.IMAGE_TAG }}
            # 기존 컨테이너를 중지합니다. (실행 중인 경우)
            docker stop itsmine || true
            # 기존 컨테이너를 삭제합니다. (존재하는 경우)
            docker rm itsmine || true
            # 새로운 컨테이너를 실행합니다.
            docker run -d --name itsmine -p ${{ secrets.SERVER_PORT }}:${{ secrets.SERVER_PORT }} \
              -e SERVER_PORT=${{ secrets.SERVER_PORT }} \
              -e DB_URL=${{ secrets.DB_URL }} \
              -e DB_USER=${{ secrets.DB_USER }} \
              -e DB_PASSWORD=${{ secrets.DB_PASSWORD }} \
              -e JWT_KEY=${{ secrets.JWT_KEY }} \
              -e ADMIN_TOKEN=${{ secrets.ADMIN_TOKEN }} \
              -e AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }} \
              -e AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }} \
              -e AWS_REGION=${{ secrets.AWS_REGION }} \
              -e AWS_ACCOUNT_ID=${{ secrets.AWS_ACCOUNT_ID }} \
              -e RABBITMQ_BROKER=${{ secrets.RABBITMQ_BROKER }} \
              -e RABBITMQ_PORT=${{ secrets.RABBITMQ_PORT }} \
              -e RABBITMQ_USERNAME=${{ secrets.RABBITMQ_USERNAME }} \
              -e RABBITMQ_PASSWORD=${{ secrets.RABBITMQ_PASSWORD }} \
              -e RABBITMQ_VIRTUAL_HOST=${{ secrets.RABBITMQ_VIRTUAL_HOST }} \
              -e REDIS_DOMAIN=${{ secrets.REDIS_DOMAIN }} \
              -e REDIS_PORT=${{ secrets.REDIS_PORT }} \
              -e ACTIVEMQ_BROKER=${{ secrets.ACTIVEMQ_BROKER }} \
              -e ACTIVEMQ_USER=${{ secrets.ACTIVEMQ_USER }} \
              -e ACTIVEMQ_PASSWORD=${{ secrets.ACTIVEMQ_PASSWORD }} \
              -e CLOUD_AWS_S3_BUCKET=${{ secrets.CLOUD_AWS_S3_BUCKET }} \
              -e CLOUD_AWS_S3_DOMAIN=${{ secrets.CLOUD_AWS_S3_DOMAIN }} \
              -e CLOUD_AWS_REGION_STATIC=${{ secrets.CLOUD_AWS_REGION_STATIC }} \
              -e CLOUD_AWS_CREDENTIALS_ACCESSKEY=${{ secrets.CLOUD_AWS_CREDENTIALS_ACCESSKEY }} \
              -e CLOUD_AWS_CREDENTIALS_SECRETKEY=${{ secrets.CLOUD_AWS_CREDENTIALS_SECRETKEY }} \
              -e CLOUD_AWS_DYNAMODB_ACCESSKEY=${{ secrets.CLOUD_AWS_DYNAMODB_ACCESSKEY }} \
              -e CLOUD_AWS_DYNAMODB_SECRETKEY=${{ secrets.CLOUD_AWS_DYNAMODB_SECRETKEY }} \
              -e ACTIVEMQ_QNAME=${{ secrets.ACTIVEMQ_QNAME }} \
              -e STOMP_HOST=${{ secrets.STOMP_HOST }} \
              ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/itsmine-repository:${{ steps.tag_image.outputs.IMAGE_TAG }}